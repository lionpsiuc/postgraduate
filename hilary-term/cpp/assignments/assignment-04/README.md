# C++ Programming

## Assignment 4 - `template`d Matrix `class`

### Question 1 - `Makefile`

See `Makefile`.

### Question 2 - `template`d Functions

See `templated.cc`.

### Question 3 - Logging

See `logging.cc`.

### Question 4 - Matrix `class`

See `matrix.h`.

### Question 5 - Gauss-Jordan Elimination

See `matrix-operations.cc`.

### Question 6 - Putting It All Together

See `assignment4.cc`.

### Question 7 - AI `template`d Matrix `class`

Using ChatGPT o3-mini-high, I asked it the following:

    Can you please generate a templated class to represent a matrix in C++, ensuring to include error catching, versions of copy and move assignments and constructors to call both const and non-const depending on whether we have a const object, and a way to use different data types (i.e., float, double, int, etc.) for our matrix (vector) data.

The answer it gave me can be seen in `ai-matrix.h`.

We can see that it created a `template`d `Matrix` class for handling two-dimensional data structures. The class stores its data in a `private` `std::vector<T>` container, along with `rows` and `cols` variables to track its dimensions. This is different from our implementation which uses raw pointers for data storage, requiring manual memory management through constructors and destructors. The AI version leverages RAII by using a standard container, eliminating the need for an explicit destructor.

We notice that the code generated by ChatGPT o3-mini-high provides several constructors - a `default` constructor creating an empty matrix, a constructor with dimensions and optional `default` value, and an initialiser list constructor allowing matrices to be created directly from nested lists. It explicitly defines both copy and move semantics with appropriate constructors and assignment operators, all following good practices like checking for self-assignment and properly moving resources. Our implementation also defines similar operations but uses raw pointer manipulation and explicit memory allocation.

The `Matrix` class provides element access through `operator` with both non-`const` and `const` versions for modifying and reading elements respectively, similar to our implementation. The bounds checking is present in both versions, though our implementation adds detailed source location information in error messages through the `sourceline` function. Both implementations throw `std::out_of_range` exceptions when trying to access elements outside the matrix dimensions.

One key difference is that it doesn't use any constraints on the `template` parameter `T`, allowing it to work with any type, while our implementation uses the `Number` `concept` to restrict the `template` to numeric types. This makes the the generated version more generic but less specialised for mathematical operations. There are no mathematical operations like addition and multiplication which are present in my solution.

Another important distinction is the lack of file I/O capabilities - our implementation includes a constructor that can read matrix data directly from a file. The AI version instead offers a `print` method for displaying the matrix contents, which could be useful for debugging but serves a different purpose than the output stream operator we make use of.

If I were to improve the AI version, I would add the mathematical operations and file I/O capabilities from our implementation, while keeping the standard container usage for memory management. However, if I were to improve our implementation, I would consider using `std::vector` instead of raw pointers to simplify the memory management aspects. The AI version is more generic while our one is more tailored to numeric computations, thanks to the `Number` `concept`.

### Question 8 - Short Programmes

#### a) Simple Traits

See `is-floating.cc`.

One can use `std::enable_if` in conjunction with `is-floating.cc` to compile functions based on whether a type is a `float` or not. This is a nice example of 'substitution failure is not an error' (SFINAE); essentially, through the use of conditionally compiling a function depending on whether a type is a `float` or not, we are using the idea that if a substitution (during template resolution) results in an invalid expression, the compiler will not report an error but will instead remove the specialisation.

#### b) Exception Handling

See `try-catch.cc`.

##### (i) `class` `template` Argument Deduction

See `ctad.cc`.
