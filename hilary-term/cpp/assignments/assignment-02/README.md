# C++ Programming

## Assignment 2 - Implementing a Gaussian Distribution `class`

### Question 1 - `Makefile`

See `Makefile`.

### Questions 2-6

See `assignment2.cc`.

### Question 7 - AI `class`

Using Claude 3.7 Sonnet, I asked it the following:

    Can you please generate a C++ class for a Gaussian distribution?

The answer it gave me can be seen in `ai-class.cc`.

We can see that the `GaussianDistribution` constructor uses an intialiser list to set the mean and standard deviation, and seeds the random number generator with a random device, ensuring that the object starts in a well-defined state immediately upon creation. There is no explicit definition of a destructor because the class does not manage any dynamic memory or other resources that require custom cleanup. No copy constructor or assignment operators are defined, meaning that the compiler-generated ones will perform member-wise (shallow) copies - this may be problematic for such a `class` which manages a random number generator. Copying the generator and distribution means that two objects might share the same internal state, leading to duplicate random sequences.

In terms of the member functions, we can see that `pdf`, `cdf`, `quantile`, `getMean`, and `getStdDev` are declared as `const` because they perform calculatioins or simply return stored values without changing any of the member variables. Declaring these as `const` is appropriate, and considered best practice, since they will not alter the object's state.

### Question 8 - Written

#### a) Destructor

For our `class`, which only contains fundamental data members (simply a `double` for both our mean and standard deviation) and does not manage any dynamic allocation of resources, there is no need to write our own destructor. The destructor generated by the the compiler will automatically call the destructors of each member, which is enough.

According to the C++ Core Guidelines, one should only provide custom implementations (of constructors, assignments, and destructors) if the `class` manages resources (i.e., dynamic memory allocation, file handles, etc.) which require explicit cleanup - known as the Rule of Zero, which states that if our `class` does not need to manage resources, we should let the compiler generate these functions. Clearly, in our case, there is no need to write an explicit destructor.

The same is true for the copy constructor and assignment - since our `class` only contains members that can be safely copied with a shallow copy, the default versions generated by the compiler are enough. Such functions are really only necessary to perform a deep copy or to handle resource ownership correctly.

#### b) Copy vs. Move

A copy operation creates a new object as an exact duplicate of an existing one, whereas a move operation transfers ownership of resources from one object to another, leaving the source in a valid but unspecified state. Essentially, a copy duplicates the data, whereas a move operation steals resources from the source object. For the given `class`, the declaration for the copy constructor would be the following:

```cpp
Widget(const Widget& other);
```

The move constructor would be as follows:

```cpp
Widget(Widget&& other) noexcept;
```

When a new object is created (construction), the appropriate constructor is used. In the examples given, we have the following explanations:

- `Widget B = A;` invokes the copy constructor because `B` is being initialised as a new object with the state of `A`.
- `Widget C{std::move(A)};` calls the move constructor because `C` is being initialised by transferring resources from `A`.

When we assign to an already existing object, an assignment operator is called. For example:

- `A = B;` calls the copy assignment operator because `A` already exists and is being assigned a new value.
- `B = std::move(C);` calls the move assignment operator because `B` is being updated by moving resources from `C`.

In summary, constructors are used for creating new objects, while assignment operators are used to update objects that have already been constructed.

#### c) `constexpr` Functions

A `constexpr` function is one that can be evaluated at compile-time when given constant expressions, but it doesn't have to be. In our example code, we call `const double x{square(1.234)};` which is evaluated at compile-time because of the `1.234`, but `const double y{square(dist(rd))};` depends on a value generated at runtime (the final result of `dist(rd)`). Thus, despite `square` being marked as `constexpr`, it is actually evaluated at runtime.

`constexpr_fn_broken.cc` fails to compile because it is attempting to initialise a `constexpr` variable with a value that cannot be determined at compile-time (i.e., `std::uniform_real_distribution`'s operator isn't a `constexpr` function which means that `square(dist(rd))` cannot be a constant expresion), thus violating the requirement for `constexpr` variables to be initialised with compile-time constant expressions.

Declaring a function as `consteval` tells the compiler that every call to that function must be evaluated at compile-time.

#### d) Default Parameters

Default values must be provided from rightmost parameters - once a parameter has a default, all parameters to its right must also have defaults. The default value is specified in the function declaration, and should not be repeated in the definition if separated. You cannot randomly assign defaults to any parameter since the order matters and only trailing parameters can have defaults. Default parameters do not participate in function overloading - they don't create separate function signatures. This means that two functions cannot be overloaded solely based on default arguments.

Overloaded functions are entirely separate function definitions that differ in their parameter lists (either in type, number, or both). Overloading allows you to have different implementations for different argument sets, while default parameters simply allow you to call the same function with fewer arguments by automatically filling in missing values.
